<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · Jute.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Jute.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li class="current"><a class="toctext" href="manual.html">Manual</a><ul class="internal"><li><a class="toctext" href="#Defining-tests-1">Defining tests</a></li><li><a class="toctext" href="#Assertions-1">Assertions</a></li><li><a class="toctext" href="#Grouping-tests-1">Grouping tests</a></li><li><a class="toctext" href="#Parametrizing-testcases-1">Parametrizing testcases</a></li><li><a class="toctext" href="#Testcase-tags-1">Testcase tags</a></li><li><a class="toctext" href="#run_options_manual-1">Run options</a></li></ul></li><li><a class="toctext" href="public.html">Public API</a></li><li><a class="toctext" href="internals.html">Internals</a></li><li><a class="toctext" href="history.html">Version history</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="manual.html">Manual</a></li></ul><a class="edit-page" href="https://github.com/fjarri/Jute.jl/tree/ebd7afcf9c3b80fca2c80c3f99a969afaaf7d485/docs/src/manual.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Manual</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Manual-1" href="#Manual-1">Manual</a></h1><h2><a class="nav-anchor" id="Defining-tests-1" href="#Defining-tests-1">Defining tests</a></h2><p>The entry-point file (commonly called <code>runtests.jl</code>) is simply:</p><pre><code class="language-julia">using Jute
exit(runtests())</code></pre><p>The test runner picks up any file with the name ending in <code>.test.jl</code> in the directory where the entry-point file is located, or in any subdirectories. All those files are included at the same level (with <code>using Jute</code> at the start), and all the <a href="public.html#Jute.@testcase"><code>@testcase</code></a> and <a href="public.html#Jute.@testgroup"><code>@testgroup</code></a> definitions are picked up. The <a href="public.html#Jute.@testgroup"><code>@testgroup</code></a> definitions can contain other <a href="public.html#Jute.@testgroup"><code>@testgroup</code></a> definitions and <a href="public.html#Jute.@testcase"><code>@testcase</code></a> definitions.</p><p>The <code>exit()</code> call is required to signal about any test failures to the processes that initiate the execution of the test suite, for instance CI tools. <a href="public.html#Jute.runtests"><code>runtests()</code></a> returns <code>1</code> if there were failed tests, <code>0</code> otherwise.</p><p>The <a href="public.html#Jute.@testcase"><code>@testcase</code></a> macro takes the testcase name and body:</p><pre><code class="language-julia">@testcase &quot;simple testcase&quot; begin
    @test 1 == 1
end</code></pre><h2><a class="nav-anchor" id="Assertions-1" href="#Assertions-1">Assertions</a></h2><p><code>Jute</code> relies on the assertions from <a href="http://docs.julialang.org/en/latest/stdlib/test/"><code>Base.Test</code></a>; <a href="public.html#Base.Test.@test"><code>@test</code></a>, <a href="public.html#Base.Test.@test_throws"><code>@test_throws</code></a>, <a href="public.html#Base.Test.@test_skip"><code>@test_skip</code></a> and <a href="public.html#Base.Test.@test_broken"><code>@test_broken</code></a> can be used. In addition, <code>Jute</code> has a <a href="public.html#Jute.@test_result"><code>@test_result</code></a> macro allowing one to return a custom result (e.g. the value of a benchmark from a testcase). There can be several assertions per testcase; their results will be reported separately. If the testcase does not call any assertions and does not throw any exceptions, it is considered to be passed.</p><h2><a class="nav-anchor" id="Grouping-tests-1" href="#Grouping-tests-1">Grouping tests</a></h2><p>Testcases can be grouped using <a href="public.html#Jute.@testgroup"><code>@testgroup</code></a> definitions. For example:</p><pre><code class="language-julia">@testcase &quot;tc1&quot; begin
end

@testgroup &quot;group&quot; begin
    @testcase &quot;tc2&quot; begin
    end
end

@testgroup &quot;group2&quot; begin
    @testgroup &quot;subgroup&quot; begin
        @testcase &quot;tc3&quot; begin
        end
    end
end</code></pre><p>the following testcases will be listed:</p><pre><code class="language-none">tc1
Group/tc2
Group2/Subgroup/tc3</code></pre><p>The order of testcase definition is preserved. In other words, the testcases will be executed in the same order in which they were defined.</p><h2><a class="nav-anchor" id="Parametrizing-testcases-1" href="#Parametrizing-testcases-1">Parametrizing testcases</a></h2><h3><a class="nav-anchor" id="Constant-fixtures-1" href="#Constant-fixtures-1">Constant fixtures</a></h3><p>The simplest method to parametrize a test is to supply it with an iterable:</p><pre><code class="language-julia">@testcase &quot;parametrized testcase&quot; for x in [1, 2, 3]
    @test x == 1
end

# Output:
# parametrized testcase[1]: [PASS]
# parametrized testcase[2]: [FAIL]
# parametrized testcase[3]: [FAIL]</code></pre><p>By default, <code>Jute</code> uses <code>string()</code> to convert a fixture value to a string for reporting purposes. One can assign custom labels to fixtures by passing a <code>Pair</code> of iterables instead:</p><pre><code class="language-julia">@testcase &quot;parametrized testcase&quot; for x in [1, 2, 3] =&gt; [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
    @test x == 1
end

# Output:
# parametrized testcase[one]: [PASS]
# parametrized testcase[two]: [FAIL]
# parametrized testcase[three]: [FAIL]</code></pre><p>A testcase can use several fixtures, in which case <code>Jute</code> will run the testcase function will all possible combinations of them:</p><pre><code class="language-julia">@testcase &quot;parametrized testcase&quot; for x in [1, 2], y in [3, 4]
    @test x + y == y + x
end

# Output:
# parametrized testcase[1, 3]: [PASS]
# parametrized testcase[1, 4]: [PASS]
# parametrized testcase[2, 3]: [PASS]
# parametrized testcase[2, 4]: [PASS]</code></pre><h3><a class="nav-anchor" id="Global-fixtures-1" href="#Global-fixtures-1">Global fixtures</a></h3><p>A global fixture is a more sophisticated variant of a constant fixture that has a setup and a teardown stage. For each global fixture, the setup is called before the first testcase that uses it. As for the teardown, it is either called right away (if the keyword parameter <code>instant_teardown</code> is <code>true</code>), or after the last testcase that uses it (if <code>instant_teardown</code> is <code>false</code>, which is the default). If no testcases use it (for example, they were filtered out), neither setup nor teardown will be called.</p><p>The setup and the teardown are defined by use of a single coroutine that produces the fixture iterable. The coroutine&#39;s first argument is a function that is used to return the fixture values. If <code>instant_teardown</code> is <code>false</code>, the call blocks until it is time to execute the teardown:</p><pre><code class="language-julia">db_connection = fixture() do produce
    c = db_connect()

    # this call blocks until all the testcases
    # that use the fixture are executed
    produce([c])

    close(c)
end</code></pre><p>Note that a global fixture must produce <strong>the whole iterable</strong> in one go.</p><p>Similarly to the constant fixture case, one can provide a custom identifier for the fixture via the optional second argument of <code>produce()</code>:</p><pre><code class="language-julia">db_connection = fixture() do produce
    c = db_connect()

    # this call blocks until all the testcases
    # that use the fixture are executed
    produce([c], [&quot;db_connection&quot;])

    close(c)
end</code></pre><p>Global fixtures can be parametrized by other constant or global fixtures. Similarly to the test parametrization, all possible combinations of parameters will be used to produce iterables, which will be chained together:</p><pre><code class="language-julia">fx1 = fixture() do produce
    produce(3:4)
end

fx2 = fixture(1:2, fx1) do produce, x, y
    produce([(x, y)])
end

@testcase &quot;tc&quot; for x in fx2
    @test length(x) == 2
end

# Output:
# tc[(1, 3)]: [PASS]
# tc[(1, 4)]: [PASS]
# tc[(2, 3)]: [PASS]
# tc[(2, 4)]: [PASS]</code></pre><h3><a class="nav-anchor" id="Local-fixtures-1" href="#Local-fixtures-1">Local fixtures</a></h3><p>A local fixture is a fixture whose value is created right before each call to the testcase function and destroyed afterwards. A simple example is a fixture that provides a temporary directory:</p><pre><code class="language-julia">temporary_dir = local_fixture() do produce
    dir = mktempdir()
    produce(dir) # this call will block while the testcase is being executed
    rm(dir, recursive=true)
end

@testcase &quot;tempdir test&quot; for dir in temporary_dir
    open(joinpath(dir, &quot;somefile&quot;), &quot;w&quot;)
end</code></pre><p>Note that, unlike a global fixture, a local fixture only produces <strong>one value</strong>. Local fixtures can be parametrized by any other type of fixture, including other local fixtures.</p><h2><a class="nav-anchor" id="Testcase-tags-1" href="#Testcase-tags-1">Testcase tags</a></h2><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>Tagging implementation is a work in progress for testcase macros.</p></div></div><p>Testcases can be assigned tags of the type <code>Symbol</code>. This can be used to establish a secondary grouping, independent of the primary grouping provided by modules. For example, one can tag performance tests, tests that run for a long time, unit/integration tests, tests that require a specific resource and so on. Testcases can be filtered by tags they have or don&#39;t have using <a href="manual.html#run_options_manual-1">command-line arguments</a>.</p><p>The tagging is performed by the function <a href="@ref Jute.tag"><code>tag()</code></a> that takes a <code>Symbol</code> and returns a function that tags a testcase:</p><pre><code class="language-julia">tc = tag(:foo)(testcase() do
    ... something
end)</code></pre><p>It is convenient to use the <a href="@ref Jute.:&lt;|"><code>&lt;|</code></a> operator:</p><pre><code class="language-julia">tc =
    tag(:foo) &lt;|
    testcase() do
        ... something
    end</code></pre><p>A tag can be removed from a testcase using <a href="@ref Jute.untag"><code>untag</code></a>. Note that tagging and untagging commands are applied from inner to outer, so, for example, the following code</p><pre><code class="language-julia">tc =
    tag(:foo) &lt;|
    untag(:bar) &lt;|
    untag(:foo) &lt;|
    tag(:bar) &lt;|
    testcase() do
        ... something
    end</code></pre><p>will leave <code>tc</code> with the tag <code>:foo</code>, but without the tag <code>:bar</code>.</p><h2><a class="nav-anchor" id="run_options_manual-1" href="#run_options_manual-1">Run options</a></h2><p><code>Jute</code>&#39;s <a href="public.html#Jute.runtests"><code>runtest()</code></a> picks up the options from the command line by default. Alternatively, they can be set with the <code>options</code> keyword argument of <a href="public.html#Jute.runtests"><code>runtests()</code></a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Jute.build_parser" href="#Jute.build_parser"><code>Jute.build_parser</code></a> — <span class="docstring-category">Function</span>.</div><div><p>For every option, the corresponding command-line argument names are given in parentheses. If supplied via the <code>options</code> keyword argument of <a href="public.html#Jute.runtests"><code>runtests()</code></a>, their type must be as given or <code>convert()</code>-able to it.</p><p><strong><code>:include_only</code></strong><code>:: Nullable{Regex}</code> (<code>--include-only</code>, <code>-i</code>): takes a regular expression; tests with full names that do not match it will not be executed.</p><p><strong><code>:exclude</code></strong><code>:: Nullable{Regex}</code> (<code>--exclude</code>, <code>-e</code>): takes a regular expression; tests with full names that match it will not be executed.</p><p><strong><code>:verbosuty</code></strong><code>:: Int</code> (<code>--verbosity</code>, <code>-v</code>): <code>0</code>, <code>1</code> or <code>2</code>, defines the amount of output that will be shown. <code>1</code> is the default.</p><p><strong><code>:include_only_tags</code></strong><code>:: Array{Symbol, 1}</code> (<code>--include-only-tags</code>, <code>-t</code>): include only tests with any of the specified tags. You can pass several tags to this option, separated by spaces.</p><p><strong><code>:exclude_tags</code></strong><code>:: Array{Symbol, 1}</code> (<code>--exclude-tags</code>, <code>-t</code>): exclude tests with any of the specified tags. You can pass several tags to this option, separated by spaces.</p><p><strong><code>:max_fails</code></strong><code>:: Int</code> (<code>--max-fails</code>): stop after the given amount of failed testcases (a testcase is considered failed, if at least one test in it failed, or an unhandeld exception was thrown).</p><p><strong><code>:capture_output</code></strong><code>:: Bool</code> (<code>--capture-output</code>): capture all the output from testcases and only show the output of the failed ones in the end of the test run.</p><p><strong><code>:dont_add_runtests_path</code></strong>:<code>:: Bool</code> (`–dont-add-runtests-path): capture testcase output and display only the output from failed testcases after all the testcases are finished.</p><p><strong><code>:test_file_postifx</code></strong><code>:: String</code> (<code>--test-file-postfix</code>): postfix of the files which will be picked up by the automatic testcase discovery.</p></div><a class="source-link" target="_blank" href="https://github.com/fjarri/Jute.jl/tree/ebd7afcf9c3b80fca2c80c3f99a969afaaf7d485/src/options.jl#L4-L41">source</a><br/></section><p>Run options can be accessed from a testcase or a fixture via the built-in fixture <a href="public.html#Jute.run_options"><code>run_options</code></a>.</p><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="public.html"><span class="direction">Next</span><span class="title">Public API</span></a></footer></article></body></html>
